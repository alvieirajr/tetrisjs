<!DOCTYPE html>
<html>
<head>
<meta name="description" content="[My First Tetris in JS]">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  
  <title></title>

</head>
<body>

<canvas></canvas>

<script src="pieces.js"></script>    
<script>    



    "use strict";
    var canvas = document.querySelector("canvas");
    var mapa = canvas.getContext("2d");
    var tile = canvas.getContext("2d");
    var colors = ['#27A4DD', '#9DD5C0', '#F39CC3', '#F1646C', '#FAC174'];
    var current_color = 2;


    var delta = 15;
    var map_width_in_pieces = 15;
    var map_height_in_pieces = 30;
    var map_width_in_pixels = delta * map_width_in_pieces; 
    var map_height_in_pixels = delta * map_height_in_pieces;  
    var pos_x = Math.round((delta*(map_width_in_pieces-3))/2);
    var pos_y = 0; 
    var flag_auto = false;
    

    var tile_map = new Array(map_height_in_pieces);

    var current_piece = 'lshape';
    var current_angle = 0;

    document.onkeydown = checkKey;

    function initMap(){ 

    //console.log(tile_map.length); 

    for (let l = 0; l < tile_map.length; l++) {
        tile_map[l] = new Array(map_width_in_pieces);
        for (let c = 0; c < tile_map[l].length; c++) {
            //console.log('c = ' + c);     
            //console.log('l = ' + l);   
            tile_map[l][c] = 0  
        }
    }

    tile_map[0][0] = 1;
    tile_map[0][map_width_in_pieces-1] = 2;
    tile_map[map_height_in_pieces-1][0] = 3;    
    tile_map[map_height_in_pieces-1][map_width_in_pieces-1] = 4;
    tile_map[15][7] = 3;    
    
    }

    function checkConstraintCanRotate() {
        let flag_canrotate = true;
        
        let temp_current_angle = current_angle;

        if (checkAngles(current_piece, temp_current_angle)) {
            temp_current_angle = 0;    
        } else {
            temp_current_angle++;
        }

        //     console.log(temp_current_angle);
        //
        
        flag_canrotate = (
            checkConstraintLeftCorner(temp_current_angle, delta) & 
            checkConstraintRightCorner(temp_current_angle, delta) & 
            checkConstraintBottomCorner(temp_current_angle, delta) &
            DetectCollisionOnTileInMovementToBottom(temp_current_angle) &
            DetectCollisionOnTileInMovementToLeft(temp_current_angle) &
            DetectCollisionOnTileInMovementToRight(temp_current_angle)
            );
     
        return flag_canrotate;
    }

    function checkConstraintLeftCorner(angle, delta_x) {
        delta_x = delta_x || 0;
        var flag_canmove = true;
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ; 
                    if (absolute_tile_horizontal_pos < 0) {                      
                        flag_canmove = false;
                        break;
                    }
                }             
            }
        }
        return flag_canmove;
    }

    function checkConstraintRightCorner(angle, delta_x ) {
        delta_x = delta_x || 0;  
       // console.log(angle);
        var flag_canmove = true;

        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;                   
                    if (absolute_tile_horizontal_pos == map_width_in_pieces) {
                        flag_canmove = false;
                        //console.log('absolute_tile_horizontal_pos  = ' + absolute_tile_horizontal_pos);
                    }                    
                    // console.log('absolute_tile_vertical_pos  = ' + absolute_tile_vertical_pos);
                }
            }
        }

        return flag_canmove;
    }
    
    // TODO: after call reset() adjust the piece position to not overlap the top corner.
    
    // TODO: verify if is possible use stackup without adjust the post_y value with -delta.
    
    // TODO: random piece.
    
    // TODO: random piece angle
        
    // TODO: random piece color.
    
    // TODO: stackup over collision detect on some tile.
    
    function reset() { 
        pos_x = Math.round((delta*(map_width_in_pieces-3))/2);
        pos_y = 0;         
    }
    
    function stackup(angle) {
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = (pos_y - delta) + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] = current_color;//pieces[current_piece][angle][l][c];
                }
            }
        }
        reset();          
                        
    }

    function checkConstraintBottomCorner(angle, delta_y) {
        delta_y = delta_y || 0;        
        var flag_canmove = true;
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_y = (pos_y) + (l*delta);
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    //console.log(absolute_tile_vertical_pos);          
                    if (absolute_tile_vertical_pos == map_height_in_pieces) {
                        flag_canmove = false;                        
                        stackup(angle);                        
                        return flag_canmove;
                    }             
                    //if ((pos_y - delta + (l*delta) + delta) == map_height_in_pixels) {
                      //  flag_canmove = false;
                      //รง  break;
                    //}
                }             
            }
        }
        return flag_canmove;
    }

    function DetectCollisionOnTileInMovementToBottom(piece_angle) {
        var flag_canmove = true;
        //console.log('------------');
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][piece_angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = (pos_y) + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    //console.log('absolute_tile_horizontal_pos  = ' + absolute_tile_horizontal_pos);
                    //console.log('absolute_tile_vertical_pos  = ' + absolute_tile_vertical_pos);
                    //console.log(tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos]);

                    if (absolute_tile_vertical_pos >= map_height_in_pieces) {
                        flag_canmove = false;
                        break;                    
                    } 
                    
                    if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] > 0) {
                        flag_canmove = false;
                        break;
                    }
                    
                }             
            }
        }
        return flag_canmove;
    }

    function DetectCollisionOnTileInMovementToLeft(piece_angle) {
        var flag_canmove = true;
        //console.log('------------');
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][piece_angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = pos_y + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    //console.log('absolute_tile_horizontal_pos  = ' + absolute_tile_horizontal_pos);
                    //console.log('absolute_tile_vertical_pos  = ' + absolute_tile_vertical_pos);
                    //console.log(tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos]);
                    if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] > 0) {
                        flag_canmove = false;
                        break;
                    }
                }             
            }
        }
        return flag_canmove;
    }


    function DetectCollisionOnTileInMovementToRight(piece_angle) {
        var flag_canmove = true;
        //console.log('------------');
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][piece_angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = pos_y + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    //console.log('absolute_tile_horizontal_pos  = ' + absolute_tile_horizontal_pos);
                    //console.log('absolute_tile_vertical_pos  = ' + absolute_tile_vertical_pos);
                    //console.log(tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos]);
                    if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] > 0) {
                        flag_canmove = false;
                        break;
                    }
                }             
            }
        }
        return flag_canmove;
    }    

    function checkKey(e) {

        e = e || window.event;

        if (e.keyCode == '38') {
            // up arrow
            if (checkConstraintCanRotate()) {
                // checkAngles(current_piece, current_angle);
                if (checkAngles(current_piece, current_angle)) {
                    current_angle = 0;    
                } else {
                    current_angle++;
                }
                console.log(current_angle);
           }
        }
        else if (e.keyCode == '40') {
            // down arrow     
            pos_y = pos_y + delta;   
            if (!checkConstraintBottomCorner(current_angle)  || !DetectCollisionOnTileInMovementToBottom(current_angle)) {
                pos_y = pos_y - delta;
            }
        }
        else if (e.keyCode == '37') {
            // left arrow
            pos_x = pos_x - delta;            
            if (!checkConstraintLeftCorner(current_angle) || !DetectCollisionOnTileInMovementToLeft(current_angle)) {
                pos_x = pos_x + delta; 
            }
            
        }
        else if (e.keyCode == '39') {
            // right arrow
            pos_x = pos_x + delta;
            if (!checkConstraintRightCorner(current_angle) || !DetectCollisionOnTileInMovementToRight(current_angle)) {
                pos_x = pos_x - delta;
            }

        }
    }

    function checkAngles(piece_type, angle) {
        let flag_reset_angle = false;
        switch (piece_type) {
            case 'lshape': 
            if (angle == 3) {
                flag_reset_angle = true;
            }
            break;
            case 'box':  {
                flag_reset_angle = true;
                break;
            }   
            case 'line':  {
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;
            }       
            case 'tshape' : {
                if (angle == 3) {
                    flag_reset_angle = true; 
                }
                break;       
            }
            case 'slshape': { 
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;       
            }  
            case 'srshape': {
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;       
            }                                  
            default:
            break;   
        }
        return flag_reset_angle;
    }



    initMap();

    setInterval(function(){  
    redraw(mapa, tile);
    }, 100);


    function renderPiece(mapa, tile) {
        tile.fillStyle = colors[current_color];
        
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                 //console.log('l = ' + l + ' c = ' + c);
                //console.log('current_angle = ' + current_angle);
                if (pieces[current_piece][current_angle][l][c] == 1) {             
                    tile.fillRect(pos_x+(c*delta), pos_y+(l*delta), delta, delta);    
                }
            }
        }    
    }


    function renderMap() {
        for (let l = 0; l < map_height_in_pieces; l++) {
            for (let c = 0; c < map_width_in_pieces; c++) {
                if (tile_map[l][c] > 0) {
                    mapa.fillStyle = colors[tile_map[l][c]];
                    mapa.fillRect((c*delta), (l*delta), delta, delta);   
                }            
            }
        }
    }


    function redraw (mapa, tile) {
    if (flag_auto) { pos_y = pos_y + delta; }
    
    canvas.width = map_width_in_pixels;
    canvas.height  = map_height_in_pixels;

    mapa.fillStyle = "#C7C4BF";
    mapa.fillRect(0, 0, map_width_in_pixels, map_height_in_pixels );
    
    renderMap(); 
    


    renderPiece(mapa, tile);
    
        

    }    
</script>    

</body>
</html>