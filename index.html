<!DOCTYPE html>
<html>
<head>
<meta name="description" content="[My First Tetris in JS]">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  
  <title></title>

</head>
<body>

<canvas></canvas>

<script src="constants.js"></script>    
<script src="pieces.js"></script>    
<script>    

    "use strict"; 

    var current_color = 2;

    var pos_x = Math.round((delta*(map_width_in_pieces-3))/2);
    var pos_y = 0; 
    var flag_auto = false;

    var pieces_list  = [];
    var pieces_list_length = 4;

    var tile_map = new Array(map_height_in_pieces);

    var current_piece = 'lshape';
    var current_angle = 0;

    document.onkeydown = checkKey;

    function fillPiecesList() {
        for (let i = 0; i < pieces_list_length; i++) {
            pieces_list.push( pieces_type[Math.floor((Math.random() * 4))]);
        }
    }

    function initMap() { 

        fillPiecesList();

        for (let l = 0; l < tile_map.length; l++) {
            tile_map[l] = new Array(map_width_in_pieces);
            for (let c = 0; c < tile_map[l].length; c++) {
                //console.log('c = ' + c);     
                //console.log('l = ' + l);   
                tile_map[l][c] = 0  
            }
        }

        tile_map[0][0] = 1;
        tile_map[0][map_width_in_pieces-1] = 2;
        tile_map[map_height_in_pieces-1][0] = 3;    
        tile_map[map_height_in_pieces-1][map_width_in_pieces-1] = 4;
        tile_map[15][12] = 3;   

        console.log(pieces_list); 
    
    }

    function checkConstraintCanRotate() {
        let flag_canrotate = true;
        
        let temp_current_angle = current_angle;

        if (checkAngles(current_piece, temp_current_angle)) {
            temp_current_angle = 0;    
        } else {
            temp_current_angle++;
        }

        //     console.log(temp_current_angle);
        //

        flag_canrotate = (
            checkConstraintLeftCorner(temp_current_angle, delta) & 
            checkConstraintRightCorner(temp_current_angle, delta) & 
            checkConstraintBottomCorner(temp_current_angle, delta) &
            DetectCollisionOnTileInMovement(temp_current_angle, DIRECTION_TO_LEFT) &
            DetectCollisionOnTileInMovement(temp_current_angle, DIRECTION_TO_BOTTOM) &
            DetectCollisionOnTileInMovement(temp_current_angle, DIRECTION_TO_RIGHT) 
            );         
     
        return flag_canrotate;
    }

    function checkConstraintLeftCorner(angle, delta_x) {
        delta_x = delta_x || 0;
        var flag_canmove = true;
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ; 
                    if (absolute_tile_horizontal_pos < 0) {                      
                        return false;
                    }
                }             
            }
        }
        return flag_canmove;
    }

    function checkConstraintRightCorner(angle, delta_x ) {
        delta_x = delta_x || 0;  
       // console.log(angle);
        var flag_canmove = true;

        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;                   
                    if (absolute_tile_horizontal_pos == map_width_in_pieces) {
                        return false;
                        //console.log('absolute_tile_horizontal_pos  = ' + absolute_tile_horizontal_pos);
                    }                    
                    // console.log('absolute_tile_vertical_pos  = ' + absolute_tile_vertical_pos);
                }
            }
        }

        return flag_canmove;
    }
    
    // TODO: after call reset() adjust the piece position to not overlap the top corner.
    
    // TODO: verify if is possible use stackup without adjust the post_y value with -delta.     
    
    // TODO: random piece angle        

    // TODO: create a queue of pieces changed on each reset() call.
    
    // BUG: error on rotate in bottom corner. 
    
    function reset() { 
        pos_y = delta;           
        current_color = Math.floor((Math.random() * 5)+1);
        current_piece = pieces_type[Math.floor((Math.random() * 4))];
        current_angle = 0;  
    
        pos_x = Math.round((delta*(map_width_in_pieces-3))/2);
    }
    
    function stackup(angle) {
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = (pos_y - delta) + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] = current_color;
                }
            }
        }   
        reset();                                 
    }

    function checkConstraintBottomCorner(angle, delta_y) {
        delta_y = delta_y || 0;        
        var flag_canmove = true;
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][angle][l][c] > 0) {
                    let absolute_y = (pos_y) + (l*delta);
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;
                    //console.log(absolute_tile_vertical_pos);          
                    if (absolute_tile_vertical_pos == map_height_in_pieces) {                                          
                        return false;
                    }             
                }             
            }
        }
        return flag_canmove;
    }

 function DetectCollisionOnTileInMovement(piece_angle, direction) {
        var flag_canmove = true;
        //console.log('------------');
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][piece_angle][l][c] > 0) {

                    let absolute_x = (pos_x) + (c*delta);
                    let absolute_y = (pos_y) + (l*delta);
                    let absolute_tile_horizontal_pos = parseInt((absolute_x) / delta) ;
                    let absolute_tile_vertical_pos = parseInt((absolute_y) / delta) ;

                    switch (direction) {
                        case DIRECTION_TO_LEFT : {
                            if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] < 0) {
                                return false;
                            }    
                        }       
                        case DIRECTION_TO_RIGHT : {
                            if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] > 0) {
                                return false;
                            }                                          
                        }                                                 
                        case DIRECTION_TO_BOTTOM : {
                            if (tile_map[absolute_tile_vertical_pos][absolute_tile_horizontal_pos] > 0) {                                                        
                                return false;
                            }
                        }                                      
                        default : {

                        }
                    }
                }             
            }
        }
        return flag_canmove;
    }

    var processed = false;
    
    function checkKey(e) {

        e = e || window.event;

        if (e.keyCode == '38') {        
            // up arrow.
            if (checkConstraintCanRotate()) {

                if (checkAngles(current_piece, current_angle)) {
                    current_angle = 0;    
                } else {
                    current_angle++;
                }

                //console.log(current_angle);
           }
        }
        else if (e.keyCode == '40') {
            // down arrow.     
            pos_y = pos_y + delta;               
            if (!checkConstraintBottomCorner(current_angle)  || !DetectCollisionOnTileInMovement(current_angle, DIRECTION_TO_BOTTOM)) {
                stackup(current_angle);
                //console.log('current_color = ' + current_color);

            }
        }
        else if (e.keyCode == '37') {
            // left arrow.
            pos_x = pos_x - delta;            
            if (!checkConstraintLeftCorner(current_angle) || !DetectCollisionOnTileInMovement(current_angle, DIRECTION_TO_LEFT)) {                
                pos_x = pos_x + delta; 
            }
            
        }
        else if (e.keyCode == '39') {
            // right arrow.
            pos_x = pos_x + delta;
            if (!checkConstraintRightCorner(current_angle) || !DetectCollisionOnTileInMovement(current_angle, DIRECTION_TO_RIGHT)) {
                pos_x = pos_x - delta;
            }

        }
    }

    function checkAngles(piece_type, angle) {
        let flag_reset_angle = false;
        switch (piece_type) {
            case 'lshape': 
            if (angle == 3) {
                flag_reset_angle = true;
            }
            break;
            case 'box':  {
                flag_reset_angle = true;
                break;
            }   
            case 'line':  {
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;
            }       
            case 'tshape' : {
                if (angle == 3) {
                    flag_reset_angle = true; 
                }
                break;       
            }
            case 'slshape': { 
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;       
            }  
            case 'srshape': {
                if (angle == 1) {
                    flag_reset_angle = true; 
                }
                break;       
            }                                  
            default:
            break;   
        }
        return flag_reset_angle;
    }



    initMap();

    setInterval(function(){  
    redraw(mapa, tile);
    }, 10);


    function renderPiece(mapa, tile) {
        tile.fillStyle = colors[current_color];
        
        for (let l = 0; l < 4; l++) {
            for (let c = 0; c < 4; c++) {
                if (pieces[current_piece][current_angle][l][c] == 1) {             
                    tile.fillRect(pos_x+(c*delta), pos_y+(l*delta), delta, delta);    
                }
            }
        }    
    }


    function renderMap() {
        for (let l = 0; l < map_height_in_pieces; l++) {
            for (let c = 0; c < map_width_in_pieces; c++) {
                if (tile_map[l][c] > 0) {
                    mapa.fillStyle = colors[tile_map[l][c]];
                    mapa.fillRect((c*delta), (l*delta), delta, delta);   
                } else {
                    mapa.strokeStyle = '#FFFFFF';
                    //mapa.strokeRect((c*delta)+2, (l*delta)+2, delta-2, delta-2);
                    //mapa.strokeRect((c*delta), (l*delta), delta, delta);                       
                }            
            }
        }
    }


    function redraw (mapa, tile) {
    if (flag_auto) { pos_y = pos_y + delta; }
    
    canvas.width = map_width_in_pixels;
    canvas.height  = map_height_in_pixels;

    mapa.fillStyle = background_collor;
    mapa.fillRect(0, 0, map_width_in_pixels, map_height_in_pixels );


    renderMap(); 
    


    renderPiece(mapa, tile);
    
        

    }    
</script>    

</body>
</html>